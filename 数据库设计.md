# 数据库设计

简介：

​	简单来说，数据库设计就是根据业务系统的具体需要，结合我们所选用的 DBMS（数据库管理系统），为这个业务系统构造出最优的数据存储模型。并建立好数据库中的表结构及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行访问。

##### 为什么要进行数据库设计？

|    优良的设计    |           糟糕的设计           |
| :--------------: | :----------------------------: |
|   减少数据冗余   |        存在大量数据冗余        |
| 避免数据维护异常 | 存在数据插入，更新，删除等异常 |
|   节约存储空间   |        浪费大量存储空间        |
|    高效的访问    |          访问数据低效          |

##### 要搞清楚的问题

- 实体及实体之间的关系（1对1，1对多，多对多）。
- 实体所包含的属性有什么？
- 那些属性或属性的组合可以唯一标识一个实体

##### 逻辑设计是做什么的

1. 将需求转化为数据库的逻辑模型
2. 通过 ER 图的形式对逻辑模型进行展示
3. 同所选用的具体的 DBMS 系统无关

##### 名词解释

- 关系：一个关系对应通常所说的一张表。
- 元组：表中的一行即为一个元组。
- 属性：表中的一列即为一个属性，每一个属性都有一个名称，称为属性名。
- 候选码：表中的某个属性组，它可以唯一确定一个元组。
- 主码：一个关系有多个候选码，选定其中一个为主码。
- 域：属性的取值范围。
- 分量：元组中的一个属性值。

##### ER 图例说明

- 矩形：表示实体集，矩形内写实体集的名字
- 菱形：表示联系集
- 椭圆：表示实体的属性
- 线段：将属性连接到实体集，或将实体集连接到联系集

### 数据库设计范式

##### 常见的数据库设计范式

第一范式，第二范式，第三范式及 BC 范式，以及第四，第五范式。目前大多数数据库设计遵循的范式都是 第一、二、三 范式。

##### 操作异常

- 插入异常：如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体，那么这个表就存在插入异常。
- 更新异常：如果更改表所对应的某个实例的单独属性时，需要将多行更新，那么就说这个表存在更新异常。
- 删除异常：如果删除表的某一行来反映某实体实例失效时导致另一个不同实体实例信息丢失，那么这个表中就存在删除异常。
- 数据冗余：是指相同的数据在多个地方存在，或者说表中的某个列可以由其它列计算得到，这样就说表中存在着数据冗余。

##### 第一范式（1NF）

定义：数据库表中的所有字段都是单一属性，不可再分的。

这个单一属性时由基本的数据类型锁构成的，如整数，浮点数，字符串，等。

换句话说：第一范式要求数据库中的表都是二维表。

| 用户ID |  用户名   | 密码 | 姓名 |    电话     |
| :----: | :-------: | :--: | :--: | :---------: |
|   1    | zhangsan3 | ***  | 张三 | 13011311234 |

##### 第二范式（2NF）

定义：数据库的表中不存在非关键字段对任一候选关键字段的部分函数依赖。

部分函数依赖 是指存在着组合关键字中的某一关键字决定非关键字的情况。

换句话说：所以单关键字段的表都符合第二范式。



不符合第二范式的表：

| 商品名称 | 供应商名称 | 价格 | 描述 | 重量 | 供应商电话 | 有效期 | 分类 |
| :------: | :--------: | :--: | :--: | :--: | :--------: | :----: | :--: |
|   可乐   |  饮料一厂  | 3.00 |      | 250g |   888888   | 2019.4 | 饮料 |
|   啤酒   |  饮料二厂  | 5.00 |      | 500g |   666666   | 2019.8 | 饮料 |

存在的问题：插入异常、删除异常、更新异常、数据冗余。



拆分为 符合第二范式的表：

商品表：

| 商品ID | 商品名称 | 价格 | 描述 | 重量 | 有效期 |
| :----: | :------: | :--: | :--: | :--: | :----: |
|   1    |   可乐   | 3.00 |      | 250g | 2019.4 |
|   2    |   啤酒   | 5.00 |      | 500g | 2019.8 |

供应商表：

| 供应商ID | 供应商名称 | 供应商电话 |
| :------: | :--------: | :--------: |
|    1     |  饮料一厂  |   888888   |
|    2     |  饮料二厂  |   666666   |

商品与供应商 关系表：

| 供应商ID | 商品ID |
| :------: | :----: |
|    1     |   1    |
|    2     |   2    |

##### 第三范式（3NF）

定义：第三范式是在第二范式的基础之上定义的，如果数据表中不存在非关键字字段，对任意候选关键字段的传递函数依赖则符合第三范式。



不符合第三范式的表：

| 商品名称 | 价格 | 商品描述 | 重量  | 有效期 |   分类   | 分类描述 |
| :------: | :--: | :------: | :---: | :----: | :------: | :------: |
|   可乐   | 3.00 |          | 250ml | 2019.5 | 酒水饮料 | 碳酸饮料 |
|   苹果   | 8.00 |          | 500g  | 2020.2 | 生鲜食品 |   水果   |



拆分为 符合第三范式的表：

商品表：

| 商品ID | 商品名称 | 价格 | 商品描述 | 重量  | 有效期 |
| :----: | :------: | :--: | :------: | :---: | :----: |
|   1    |   可乐   | 3.00 |          | 250ml | 2019.5 |
|   2    |   苹果   | 8.00 |          | 500g  | 2020.2 |

分类表：

| 分类ID | 分类名称 | 分类描述 |
| :----: | :------: | :------: |
|   1    | 酒水饮料 | 碳酸饮料 |
|   2    | 生鲜食品 |   水果   |

商品与分类 关系表：

| 分类ID | 商品ID |
| :----: | :----: |
|   1    |   1    |
|   2    |   2    |

##### BC范式（Boyce.Codd范式）（BCNF）

定义：

在第三范式的基础之上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合 BC范式。

也就是说如果是复合关键字，则复合关键字之间也不能存在函数依赖关系。



不符合BC范式的表：

|  供应商  | 商品ID | 供应商联系人 | 商品数量 |
| :------: | :----: | :----------: | :------: |
| 饮料一厂 |   1    |     张三     |    10    |
| 饮料一厂 |   2    |     李四     |    20    |
| 饮料二厂 |   1    |     王五     |    20    |

存在下列关系，因此不符合 BCNF 要求：

（供应商）-> （供应商联系人）

（供应商联系人）-> （供应商）

并且存在数据操作异常及数据冗余。



拆分为 符合 BC范式 的表：

|  供应商  | 商品ID | 商品数量 |
| :------: | :----: | :------: |
| 饮料一厂 |   1    |    10    |
| 饮料一厂 |   2    |    20    |
| 饮料一厂 |   1    |    20    |

供应商信息表：

|  供应商  | 供应商联系人 |
| :------: | :----------: |
| 饮料一厂 |     张三     |
| 饮料一厂 |     李四     |
| 饮料二厂 |     王五     |

### 物理设计

##### 设计规范

1. 选择合适的数据库管理系统。

   - Oracle、SQLServer 商业数据库（更适合企业级项目）
   - MySQL、PgSQL 开源数据库（适用于互联网项目）

2. 定义数据库、表及字段的命名规范。

   - 可读性原则：

     ​	使用大写和小写来格式化的库对象名字以获得良好的可读性。

     ​	例如：使用 CustAddress 而不是 custaddress 来提高可读性。（这里要注意有些 DBMS 系统对表名的大小写是敏感的）

   - 表意性原则：

     ​	对象的名字应该能够描述它所标识的对象。

     ​	例如，对于表，表的名称应该能够体现表中存储的数据内容；对于存储过程，存储过程名称应该能够体现存储过程的功能。

   - 长名原则

     ​	尽可能少使用或者不使用缩写，适用于数据库（DATABASE）名之外的任一对象。

3. 根据所选的 DBMS 系统选择合适的字段类型。

   ​	列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。

   - 在对数据进行比较（查询条件，JOIN条件及排序）操作时：同样的数据，字符处理往往比数字处理慢。
   - 在数据库中，数据处理以页为单位，列的长度越小，利于性能提升。
   - char 与 varchar 如何选择：
     1. 如果列中药存储的数据长度差不多是一致的，则应该考虑用 char，否则应该考虑用 varchar。
     2. 如果列中的最大数据长度小于 50Byte，则一般也考虑用 char。（当然，如果这个列很少用，则基于节省空间和减少 I/O 的考虑，还是可以选择用 varchar）
     3. 一般不宜定义大于 50Byte 的 char 类型列。

4. 反范式化设计。

##### 如何选择主键

1. 区分业务主键和数据库主键

   ​	业务主键用于标识业务数据，进行表与表之间的关联；

   ​	数据库主键为了优化数据存储（Innodb 会生成 6 个字节的隐含主键）

2. 根据数据库的类型，考虑主键是否要顺序增长

   ​	有些数据库是按主键的顺序逻辑存储的

3. 主键的字段类型所占用空间要尽可能的小

   ​	对于使用聚集索引方式存储的表，每个索引后都会附加主键信息。

##### 避免使用外键约束

1. 降低数据导入的效率
2. 增加维护成本
3. 虽然不建议使用外键约束，但是相关联的列上一定要建立索引

##### 避免使用触发器

1. 减低数据导入的效率
2. 可能会出现意想不到的数据异常
3. 使业务逻辑变的复杂。

##### 关于预留字段

1. 无法准确的知道预留字段的类型。
2. 无法准确的知道预留字段中所存储的内容。
3. 后期维护预留字段所要的成本，同增加一个字段所需要的成本是相同的。
4. 严禁使用预留字段。

#####  反范式化

​	反范式化是针对范式化而言的，在前面介绍了数据库设计的第三范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反，而允许存在少量的输出冗余，换句话来说，反范式化就是使用空间来换取时间。

为什么要 反范式化：

1. 减少表的关联数量
2. 增加数据的读取效率
3. 反范式化一定要适度

### 维护和优化

##### 要做些什么：

1. 维护数据字典
2. 维护索引
3. 维护表结构
4. 在适当的时候对表进行水平拆分和垂直拆分

##### 如何维护数据字典

1. 使用第三方工具对数据字典进行维护

2. 利用数据库本身的备注字段来维护数据字典。以 MySQL 为例：增加备注

   ```sql
   CREATE TABLE customer(
   	cust_id INT AUTO_INCREMENT NOT NULL COMMENT '自增ID',
       cust_name VARCHAR(10) NOT NULL COMMENT '客户姓名',
       PRIMARY KEY (cust_id)
   ) COMMENT '客户表';
   ```

3. 导出数据字典

   ```sql
   SELECT 
   a.table_name, b.TABLE_COMMENT, a.COLUMEN_NAME, a.COLUMN_TYPE, a.COLUMN_COMMENT
   FROM information_schema.COLUMNS a
   JOIN information_schema.TABLES b
   ON a.table_schema = b.table_schema AND a.table_name = b.table_name
   WHERE a.table_name = 'customer';
   ```

   | table_name | TABLE_COMMENT | COLUMN_NAME | COLUMN_TYPE | COLUMN_COMMENT |
   | :--------: | :-----------: | :---------: | :---------: | :------------: |
   |  customer  |    客户表     |   cust_id   |   int(11)   |     自增ID     |
   |  customer  |    客户表     |  cust_name  | varchar(10) |    客户姓名    |

##### 如何维护索引

如何选择合适的列建立索引：

1. 出现在 WHERE 从句，GROUP BY 从句，ORDER BY 从句中的列
2. 可选择性高的列要放到索引的前面
3. 索引中不用包括太长的数据类型

注意事项：

1. 索引并不是越多越好，过多的索引不但会减低写效率而且会降低读的效率
2. 定期维护索引碎片
3. 在 SQL 语句中不要使用强制索引关键字

##### 如何维护表结构

注意事项：

1. 使用在线变更表结构的工具
2. 同时对数据字典进行维护
3. 控制表的宽度和大小

##### 数据库中适合的操作

1. 批量操作 VS 逐条操作，适合批量操作。
2. 禁止使用 Select * 这样的查询
3. 控制使用用户自定义函数
4. 不用使用数据库中的全文索引



### 表的拆分

##### 垂直拆分

为了控制表的宽度可以进行表的垂直拆分

1. 经常一起查询的列放到一起
2. text, blob 等大字段拆分出到附加表中

##### 水平拆分

为了控制表的大小可以进行表的水平拆分

使用 Hash key。

